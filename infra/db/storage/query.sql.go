// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	domain "github.com/litvivan/ilyway/app/models"
)

const getItem = `-- name: GetItem :one
SELECT id, title, description, participant_count, activity_type, city, author_name, author_rating, image_url, full_address, has_reward, duration, start_at, created_at, updated_at FROM items
WHERE id = $1
`

func (q *Queries) GetItem(ctx context.Context, id int32) (Item, error) {
	row := q.db.QueryRowContext(ctx, getItem, id)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ParticipantCount,
		&i.ActivityType,
		&i.City,
		&i.AuthorName,
		&i.AuthorRating,
		&i.ImageUrl,
		&i.FullAddress,
		&i.HasReward,
		&i.Duration,
		&i.StartAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertItem = `-- name: InsertItem :one
INSERT INTO items (title, description, participant_count, activity_type, city, author_name, author_rating, image_url, full_address, has_reward, duration, start_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, title, description, participant_count, activity_type, city, author_name, author_rating, image_url, full_address, has_reward, duration, start_at, created_at, updated_at
`

type InsertItemParams struct {
	Title            string
	Description      string
	ParticipantCount int32
	ActivityType     domain.ActivityType
	City             string
	AuthorName       string
	AuthorRating     float64
	ImageUrl         string
	FullAddress      string
	HasReward        bool
	Duration         string
	StartAt          time.Time
}

func (q *Queries) InsertItem(ctx context.Context, arg InsertItemParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, insertItem,
		arg.Title,
		arg.Description,
		arg.ParticipantCount,
		arg.ActivityType,
		arg.City,
		arg.AuthorName,
		arg.AuthorRating,
		arg.ImageUrl,
		arg.FullAddress,
		arg.HasReward,
		arg.Duration,
		arg.StartAt,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ParticipantCount,
		&i.ActivityType,
		&i.City,
		&i.AuthorName,
		&i.AuthorRating,
		&i.ImageUrl,
		&i.FullAddress,
		&i.HasReward,
		&i.Duration,
		&i.StartAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listItems = `-- name: ListItems :many
SELECT id, title, description, participant_count, activity_type, city, author_name, author_rating, image_url, full_address, has_reward, duration, start_at, created_at, updated_at FROM items
WHERE
    participant_count >= coalesce($1::int, participant_count) AND
    participant_count <= coalesce($2::int, participant_count) AND
    activity_type = coalesce($3::text, activity_type) AND
    author_rating >= coalesce($4::float, author_rating) AND
    city = coalesce($5::text, city) AND
    start_at >= coalesce($6::timestamp, start_at) AND
    start_at <= coalesce($7::timestamp, start_at)
ORDER BY id
`

type ListItemsParams struct {
	MinParticipantCount sql.NullInt32
	MaxParticipantCount sql.NullInt32
	ActivityType        sql.NullString
	MinAuthorRating     sql.NullFloat64
	City                sql.NullString
	MinStartAt          sql.NullTime
	MaxStartAt          sql.NullTime
}

func (q *Queries) ListItems(ctx context.Context, arg ListItemsParams) ([]Item, error) {
	rows, err := q.db.QueryContext(ctx, listItems,
		arg.MinParticipantCount,
		arg.MaxParticipantCount,
		arg.ActivityType,
		arg.MinAuthorRating,
		arg.City,
		arg.MinStartAt,
		arg.MaxStartAt,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ParticipantCount,
			&i.ActivityType,
			&i.City,
			&i.AuthorName,
			&i.AuthorRating,
			&i.ImageUrl,
			&i.FullAddress,
			&i.HasReward,
			&i.Duration,
			&i.StartAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
